import { Abi, ExtractAbiFunctionNames, ExtractAbiFunction, AbiParametersToPrimitiveTypes } from "abitype";
import { Address, RpcStateOverride } from "viem";
import { AccountOpts, BuildUserOperationResponse, SendUserOperationResponse } from "./types";
export declare class Instance<A extends Abi, F extends Abi> {
    private readonly accountAbi;
    private readonly factoryAbi;
    private readonly factoryAddress;
    private readonly entryPointAddress;
    private readonly ethClient;
    private readonly bundlerClient;
    private salt;
    private waitTimeoutMs;
    private waitIntervalMs;
    private sender;
    private initCode;
    private callData;
    private nonceKey;
    private stateOverrideSet?;
    private setFactoryData;
    private requestSignature;
    private requestGasPrice;
    private requestGasValues;
    private requestPaymaster?;
    private onBuild?;
    constructor(opts: AccountOpts<A, F>);
    private getInitCode;
    private getChainId;
    private getByteCode;
    private resolveSenderMeta;
    getWaitTimeoutMs(): number;
    setWaitTimeoutMs(time: number): Instance<A, F>;
    getWaitIntervalMs(): number;
    setWaitIntervalMs(time: number): Instance<A, F>;
    getSalt(): bigint;
    setSalt(salt: bigint): Instance<A, F>;
    getNonceKey(): bigint;
    setNonceKey(key: bigint): Instance<A, F>;
    getNonce(): Promise<bigint>;
    setStateOverrideSetForEstimate(stateOverrideSet: RpcStateOverride): Instance<A, F>;
    clearStateOverrideSetForEstimate(): Instance<A, F>;
    getSender(): Promise<Address>;
    encodeCallData<M extends ExtractAbiFunctionNames<A>>(method: M, inputs: AbiParametersToPrimitiveTypes<ExtractAbiFunction<A, M>["inputs"]>): Instance<A, F>;
    buildUserOperation(): Promise<BuildUserOperationResponse>;
    sendUserOperation(): Promise<SendUserOperationResponse>;
}
