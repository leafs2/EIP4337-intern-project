"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Instance = void 0;
const viem_1 = require("viem");
const ethers_1 = require("ethers");
const Hooks = __importStar(require("./hooks"));
const Bundler = __importStar(require("../bundler"));
const EntryPoint = __importStar(require("../entryPoint"));
class Instance {
    constructor(opts) {
        this.sender = viem_1.zeroAddress;
        this.initCode = "0x";
        this.callData = "0x";
        this.nonceKey = 0n;
        this.accountAbi = opts.accountAbi;
        this.factoryAbi = opts.factoryAbi;
        this.factoryAddress = opts.factoryAddress;
        this.entryPointAddress =
            opts.entryPointAddress ?? EntryPoint.DEFAULT_ADDRESS;
        this.ethClient = opts.ethClient;
        this.bundlerClient = opts.bundlerClient ?? this.ethClient;
        this.salt = opts.salt ?? 0n;
        this.waitTimeoutMs = opts.waitTimeoutMs ?? 60000;
        this.waitIntervalMs = opts.waitIntervalMs ?? 3000;
        this.setFactoryData = opts.setFactoryData;
        this.requestSignature = opts.requestSignature;
        this.requestGasPrice =
            opts.requestGasPrice ??
                Hooks.RequestGasPrice.withEthClient(this.ethClient);
        this.requestGasValues =
            opts.requestGasValues ??
                Hooks.RequestGasValues.withEthClient(this.bundlerClient);
        this.requestPaymaster = opts.requestPaymaster;
        this.onBuild = opts.onBuild;
    }
    async getInitCode() {
        if (this.initCode === "0x") {
            this.initCode = (0, viem_1.concat)([
                this.factoryAddress,
                await this.setFactoryData(this.salt, (method, inputs) => {
                    return (0, viem_1.encodeFunctionData)({
                        abi: this.factoryAbi,
                        functionName: method,
                        args: inputs,
                    });
                }),
            ]);
        }
        return this.initCode;
    }
    async getChainId() {
        if (this.ethClient instanceof ethers_1.JsonRpcProvider) {
            const network = await this.ethClient.getNetwork();
            return Number(network.chainId);
        }
        return this.ethClient.getChainId();
    }
    async getByteCode(address) {
        if (this.ethClient instanceof ethers_1.JsonRpcProvider) {
            return this.ethClient.getCode(address);
        }
        return this.ethClient.getBytecode({ address });
    }
    async resolveSenderMeta() {
        const sender = await this.getSender();
        const [nonce, code] = await Promise.all([
            this.getNonce(),
            this.getByteCode(sender),
        ]);
        return {
            nonce,
            initCode: code === undefined ? await this.getInitCode() : "0x",
        };
    }
    getWaitTimeoutMs() {
        return this.waitTimeoutMs;
    }
    setWaitTimeoutMs(time) {
        this.waitTimeoutMs = time;
        return this;
    }
    getWaitIntervalMs() {
        return this.waitIntervalMs;
    }
    setWaitIntervalMs(time) {
        this.waitIntervalMs = time;
        return this;
    }
    getSalt() {
        return this.salt;
    }
    setSalt(salt) {
        this.salt = salt;
        this.sender = viem_1.zeroAddress;
        this.initCode = "0x";
        return this;
    }
    getNonceKey() {
        return this.nonceKey;
    }
    setNonceKey(key) {
        this.nonceKey = key;
        return this;
    }
    async getNonce() {
        if (this.ethClient instanceof ethers_1.JsonRpcProvider) {
            return new ethers_1.Contract(this.entryPointAddress, EntryPoint.CONTRACT_ABI, this.ethClient).getNonce(await this.getSender(), this.nonceKey);
        }
        return this.ethClient.readContract({
            address: this.entryPointAddress,
            abi: EntryPoint.CONTRACT_ABI,
            functionName: "getNonce",
            args: [await this.getSender(), this.nonceKey],
        });
    }
    setStateOverrideSetForEstimate(stateOverrideSet) {
        this.stateOverrideSet = stateOverrideSet;
        return this;
    }
    clearStateOverrideSetForEstimate() {
        this.stateOverrideSet = undefined;
        return this;
    }
    async getSender() {
        if (this.sender !== viem_1.zeroAddress) {
            return this.sender;
        }
        if (this.ethClient instanceof ethers_1.JsonRpcProvider) {
            try {
                await new ethers_1.Contract(this.entryPointAddress, EntryPoint.CONTRACT_ABI, this.ethClient).getSenderAddress.staticCall(this.getInitCode());
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (error) {
                const addr = error?.revert?.args?.[0];
                if (!addr)
                    throw error;
                this.sender = addr;
            }
        }
        else {
            try {
                await this.ethClient.simulateContract({
                    address: this.entryPointAddress,
                    abi: EntryPoint.CONTRACT_ABI,
                    functionName: "getSenderAddress",
                    args: [await this.getInitCode()],
                });
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (error) {
                const metaMessage = error?.metaMessages?.[1];
                if (typeof metaMessage !== "string")
                    throw error;
                const addr = metaMessage.trim().slice(1, -1);
                if (!(0, viem_1.isAddress)(addr))
                    throw error;
                this.sender = addr;
            }
        }
        return this.sender;
    }
    encodeCallData(method, inputs) {
        this.callData = (0, viem_1.encodeFunctionData)({
            abi: this.accountAbi,
            functionName: method,
            args: inputs,
        });
        return this;
    }
    async buildUserOperation() {
        const callData = this.callData;
        this.callData = "0x";
        const [sender, senderMeta, gasPrice, signature, chainId] = await Promise.all([
            this.getSender(),
            this.resolveSenderMeta(),
            this.requestGasPrice(),
            this.requestSignature("dummy", "0xdead"),
            this.getChainId(),
        ]);
        const init = {
            ...EntryPoint.DEFAULT_USEROP,
            sender,
            ...senderMeta,
            ...gasPrice,
            callData,
            signature,
        };
        const est = await this.requestGasValues(init, this.entryPointAddress, this.stateOverrideSet);
        const useropWithGas = { ...init, ...est };
        const pm = this.requestPaymaster != undefined
            ? await this.requestPaymaster(useropWithGas, this.entryPointAddress)
            : {};
        const userOpWithPM = {
            ...useropWithGas,
            ...pm,
        };
        const userOpHash = EntryPoint.calculateUserOpHash(userOpWithPM, this.entryPointAddress, chainId);
        const userOperation = {
            ...userOpWithPM,
            signature: await this.requestSignature("final", userOpHash),
        };
        this.onBuild?.(userOperation);
        return { userOperation, userOpHash };
    }
    async sendUserOperation() {
        const build = await this.buildUserOperation();
        const userOpHash = await Bundler.SendUserOperationWithEthClient(build.userOperation, this.entryPointAddress, this.bundlerClient);
        return {
            userOpHash,
            wait: async () => {
                let receipt = null;
                const end = Date.now() + this.waitTimeoutMs;
                while (Date.now() < end) {
                    receipt = await Bundler.GetUserOperationReceiptWithEthClient(userOpHash, this.bundlerClient);
                    if (receipt != null) {
                        return receipt;
                    }
                    await new Promise((resolve) => setTimeout(resolve, this.waitIntervalMs));
                }
                return receipt;
            },
        };
    }
}
exports.Instance = Instance;
